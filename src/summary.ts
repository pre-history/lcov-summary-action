import { ParseLcov, FileCoverage, CoverageDiff } from './lcov_parser';
import {
  generateCoverageSpriteWithFeedback,
  getCoverageFeedbackMessage,
} from './feedback';

interface Options {
  title?: string;
  primary_color?: string;
  secondary_color?: string;
  show_files?: boolean;
  max_files_shown?: number;
  coverage_threshold?: number;
  generate_badge?: boolean;
  badge_style?: string;
  show_coverage_feedback?: boolean;
  github_context?: { owner: string; repo: string; ref: string };
}

export function generateSummary(
  covered: number,
  not_covered: number,
  options?: Options,
): string {
  const primary = options?.primary_color || '#4CAF50';
  const secondary = options?.secondary_color || '#FF5733';
  const title = options?.title || 'Project Coverage';
  const total = covered + not_covered;
  const percentage = total === 0 ? 0 : Math.round((covered / total) * 100);

  const spriteHtml = options?.show_coverage_feedback
    ? generateCoverageSpriteWithFeedback(
        percentage,
        options?.github_context,
        options?.show_coverage_feedback,
      )
    : '';

  return `## ${spriteHtml}ðŸ“Š ${title}

\`\`\`mermaid
  %%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '${covered >= not_covered ? primary : secondary}', 'secondaryColor': '${covered < not_covered ? primary : secondary}',  'primaryTextColor': '#777', 'darkMode': { 'primaryTextColor': '#777'  } }}}%%
    pie showData
    title ${title}
    "Covered" : ${covered}
    "Not covered" : ${not_covered}
\`\`\`

---
*Generated by LCovMan ðŸ¦•*`;
}

export function generateDetailedSummary(
  result: ParseLcov,
  diff?: CoverageDiff | null,
  options?: Options,
): string {
  const primary = options?.primary_color || '#4CAF50';
  const secondary = options?.secondary_color || '#FF5733';
  const title = options?.title || 'Project Coverage';
  const showFiles = options?.show_files !== false;
  const maxFiles = options?.max_files_shown || 10;

  const threshold = options?.coverage_threshold || 0;
  const thresholdStatus = result.percentage >= threshold ? 'âœ…' : 'âŒ';
  const thresholdText =
    threshold > 0 ? ` | Threshold: ${thresholdStatus} ${threshold}%` : '';

  const spriteHtml = options?.show_coverage_feedback
    ? generateCoverageSpriteWithFeedback(
        result.percentage,
        options?.github_context,
        options?.show_coverage_feedback,
      )
    : '';

  let summary = `## ${spriteHtml}ðŸ“Š ${title}

### Overall Coverage
- **${result.percentage}%** covered (${result.covered}/${result.covered + result.not_covered} lines)${thresholdText}
- **${result.total_files}** files analyzed

\`\`\`mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '${result.covered >= result.not_covered ? primary : secondary}', 'secondaryColor': '${result.covered < result.not_covered ? primary : secondary}',  'primaryTextColor': '#777', 'darkMode': { 'primaryTextColor': '#777'  } }}}%%
pie showData
title ${title}
"Covered" : ${result.covered}
"Not covered" : ${result.not_covered}
\`\`\`
`;

  // Show coverage diff if available
  if (diff) {
    const diffSign = diff.percentage_diff >= 0 ? '+' : '';
    const diffEmoji = diff.percentage_diff >= 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';

    summary += `
### Coverage Changes ${diffEmoji}
- **${diffSign}${diff.percentage_diff}%** coverage change
- **${diff.covered_diff >= 0 ? '+' : ''}${diff.covered_diff}** lines covered

`;

    if (diff.files_changed.length > 0) {
      summary += `### Changed Files (${diff.files_changed.length})
| File | Base | Current | Change |
|------|------|---------|--------|
`;
      diff.files_changed.slice(0, maxFiles).forEach((file) => {
        const changeEmoji = file.coverage_diff >= 0 ? 'âœ…' : 'âŒ';
        const changeSign = file.coverage_diff >= 0 ? '+' : '';
        summary += `| \`${file.filename}\` | ${file.base_coverage}% | ${file.current_coverage}% | ${changeEmoji} ${changeSign}${file.coverage_diff}% |\n`;
      });

      if (diff.files_changed.length > maxFiles) {
        summary += `\n*... and ${diff.files_changed.length - maxFiles} more files*\n`;
      }
      summary += '\n';
    }

    if (diff.new_files.length > 0) {
      summary += `### New Files (${diff.new_files.length})
| File | Coverage |
|------|----------|
`;
      diff.new_files.slice(0, maxFiles).forEach((file) => {
        const coverageEmoji =
          file.percentage >= 80 ? 'âœ…' : file.percentage >= 50 ? 'âš ï¸' : 'âŒ';
        summary += `| \`${file.filename}\` | ${coverageEmoji} ${file.percentage}% |\n`;
      });

      if (diff.new_files.length > maxFiles) {
        summary += `\n*... and ${diff.new_files.length - maxFiles} more files*\n`;
      }
      summary += '\n';
    }

    if (diff.removed_files.length > 0) {
      summary += `### Removed Files (${diff.removed_files.length})
`;
      diff.removed_files.slice(0, maxFiles).forEach((file) => {
        summary += `- \`${file.filename}\` (was ${file.percentage}%)\n`;
      });

      if (diff.removed_files.length > maxFiles) {
        summary += `\n*... and ${diff.removed_files.length - maxFiles} more files*\n`;
      }
      summary += '\n';
    }
  }

  // Show file breakdown if requested
  if (showFiles && result.files.length > 0) {
    // Show files with low coverage first
    const lowCoverageFiles = result.files
      .filter((f) => f.percentage < 80)
      .sort((a, b) => a.percentage - b.percentage);

    if (lowCoverageFiles.length > 0) {
      summary += `### Files with Low Coverage (< 80%)
| File | Coverage | Lines |
|------|----------|-------|
`;
      lowCoverageFiles.slice(0, maxFiles).forEach((file) => {
        const coverageEmoji = file.percentage >= 50 ? 'âš ï¸' : 'âŒ';
        summary += `| \`${file.filename}\` | ${coverageEmoji} ${file.percentage}% | ${file.covered}/${file.total} |\n`;
      });

      if (lowCoverageFiles.length > maxFiles) {
        summary += `\n*... and ${lowCoverageFiles.length - maxFiles} more files*\n`;
      }
      summary += '\n';
    }

    // Show top performing files
    const topFiles = result.files
      .filter((f) => f.percentage >= 80)
      .sort((a, b) => b.percentage - a.percentage)
      .slice(0, 5);

    if (topFiles.length > 0) {
      summary += `### Top Performing Files âœ¨
| File | Coverage | Lines |
|------|----------|-------|
`;
      topFiles.forEach((file) => {
        summary += `| \`${file.filename}\` | âœ… ${file.percentage}% | ${file.covered}/${file.total} |\n`;
      });
      summary += '\n';
    }
  }

  // Add badge if requested
  if (options?.generate_badge) {
    const badgeStyle = options?.badge_style || 'flat';
    let badgeColor = 'red';
    if (result.percentage >= 80) badgeColor = 'brightgreen';
    else if (result.percentage >= 60) badgeColor = 'yellow';
    else if (result.percentage >= 40) badgeColor = 'orange';

    const percentageText = `${result.percentage}%25`;
    const badgeUrl = `https://img.shields.io/badge/coverage-${percentageText}-${badgeColor}?style=${badgeStyle}`;
    const badgeMarkdown = `![Coverage](${badgeUrl})`;

    summary += `### Coverage Badge ðŸ“Š
${badgeMarkdown}

`;
  }

  summary += `---
*Generated by LCovMan ðŸ¦•*`;

  return summary;
}
