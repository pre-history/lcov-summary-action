import { ParseLcov, FileCoverage, CoverageDiff } from './lcov_parser';

interface Options {
  title?: string;
  primary_color?: string;
  secondary_color?: string;
  show_files?: boolean;
  max_files_shown?: number;
}

export function generateSummary(
  covered: number,
  not_covered: number,
  options?: Options,
): string {
  const primary = options?.primary_color || '#4CAF50';
  const secondary = options?.secondary_color || '#FF5733';
  const title = options?.title || 'Project Coverage';
  return `## 📊 ${title}

\`\`\`mermaid
  %%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '${covered >= not_covered ? primary : secondary}', 'secondaryColor': '${covered < not_covered ? primary : secondary}',  'primaryTextColor': '#777', 'darkMode': { 'primaryTextColor': '#777'  } }}}%%
    pie showData
    title ${title}
    "Covered" : ${covered}
    "Not covered" : ${not_covered}
\`\`\`

---
*Generated by LCovMan 🦕*`;
}

export function generateDetailedSummary(
  result: ParseLcov,
  diff?: CoverageDiff | null,
  options?: Options,
): string {
  const primary = options?.primary_color || '#4CAF50';
  const secondary = options?.secondary_color || '#FF5733';
  const title = options?.title || 'Project Coverage';
  const showFiles = options?.show_files !== false;
  const maxFiles = options?.max_files_shown || 10;

  let summary = `## 📊 ${title}

### Overall Coverage
- **${result.percentage}%** covered (${result.covered}/${result.covered + result.not_covered} lines)
- **${result.total_files}** files analyzed

\`\`\`mermaid
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '${result.covered >= result.not_covered ? primary : secondary}', 'secondaryColor': '${result.covered < result.not_covered ? primary : secondary}',  'primaryTextColor': '#777', 'darkMode': { 'primaryTextColor': '#777'  } }}}%%
pie showData
title ${title}
"Covered" : ${result.covered}
"Not covered" : ${result.not_covered}
\`\`\`
`;

  // Show coverage diff if available
  if (diff) {
    const diffSign = diff.percentage_diff >= 0 ? '+' : '';
    const diffEmoji = diff.percentage_diff >= 0 ? '📈' : '📉';
    
    summary += `
### Coverage Changes ${diffEmoji}
- **${diffSign}${diff.percentage_diff}%** coverage change
- **${diff.covered_diff >= 0 ? '+' : ''}${diff.covered_diff}** lines covered

`;

    if (diff.files_changed.length > 0) {
      summary += `### Changed Files (${diff.files_changed.length})
| File | Base | Current | Change |
|------|------|---------|--------|
`;
      diff.files_changed.slice(0, maxFiles).forEach(file => {
        const changeEmoji = file.coverage_diff >= 0 ? '✅' : '❌';
        const changeSign = file.coverage_diff >= 0 ? '+' : '';
        summary += `| \`${file.filename}\` | ${file.base_coverage}% | ${file.current_coverage}% | ${changeEmoji} ${changeSign}${file.coverage_diff}% |\n`;
      });
      
      if (diff.files_changed.length > maxFiles) {
        summary += `\n*... and ${diff.files_changed.length - maxFiles} more files*\n`;
      }
      summary += '\n';
    }

    if (diff.new_files.length > 0) {
      summary += `### New Files (${diff.new_files.length})
| File | Coverage |
|------|----------|
`;
      diff.new_files.slice(0, maxFiles).forEach(file => {
        const coverageEmoji = file.percentage >= 80 ? '✅' : file.percentage >= 50 ? '⚠️' : '❌';
        summary += `| \`${file.filename}\` | ${coverageEmoji} ${file.percentage}% |\n`;
      });
      
      if (diff.new_files.length > maxFiles) {
        summary += `\n*... and ${diff.new_files.length - maxFiles} more files*\n`;
      }
      summary += '\n';
    }

    if (diff.removed_files.length > 0) {
      summary += `### Removed Files (${diff.removed_files.length})
`;
      diff.removed_files.slice(0, maxFiles).forEach(file => {
        summary += `- \`${file.filename}\` (was ${file.percentage}%)\n`;
      });
      
      if (diff.removed_files.length > maxFiles) {
        summary += `\n*... and ${diff.removed_files.length - maxFiles} more files*\n`;
      }
      summary += '\n';
    }
  }

  // Show file breakdown if requested
  if (showFiles && result.files.length > 0) {
    // Show files with low coverage first
    const lowCoverageFiles = result.files
      .filter(f => f.percentage < 80)
      .sort((a, b) => a.percentage - b.percentage);
    
    if (lowCoverageFiles.length > 0) {
      summary += `### Files with Low Coverage (< 80%)
| File | Coverage | Lines |
|------|----------|-------|
`;
      lowCoverageFiles.slice(0, maxFiles).forEach(file => {
        const coverageEmoji = file.percentage >= 50 ? '⚠️' : '❌';
        summary += `| \`${file.filename}\` | ${coverageEmoji} ${file.percentage}% | ${file.covered}/${file.total} |\n`;
      });
      
      if (lowCoverageFiles.length > maxFiles) {
        summary += `\n*... and ${lowCoverageFiles.length - maxFiles} more files*\n`;
      }
      summary += '\n';
    }

    // Show top performing files
    const topFiles = result.files
      .filter(f => f.percentage >= 80)
      .sort((a, b) => b.percentage - a.percentage)
      .slice(0, 5);
    
    if (topFiles.length > 0) {
      summary += `### Top Performing Files ✨
| File | Coverage | Lines |
|------|----------|-------|
`;
      topFiles.forEach(file => {
        summary += `| \`${file.filename}\` | ✅ ${file.percentage}% | ${file.covered}/${file.total} |\n`;
      });
      summary += '\n';
    }
  }

  summary += `---
*Generated by LCovMan 🦕*`;

  return summary;
}