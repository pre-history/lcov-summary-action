import * as core from '@actions/core';
import * as github from '@actions/github';
import * as fs from 'fs';
import * as path from 'path';
import { parseLcov } from './lcov_parser';
import { generateSummary } from './summary';
/**
 * Represents the working directory.
 *
 * @type {string}
 */
const WORKING_DIR = core.getInput('working-directory');
/**
 * Entry point of the program.
 *
 * @async
 * @function main
 * @returns {void}
 */
async function main() {
  const inputs = getInputs();
  const rawCoverageReport = readFileSafe(inputs.lcovFile);
  if (!rawCoverageReport) {
    await core.summary
      .addTable([
        [
          { data: 'Details', header: true },
          { data: 'Result', header: true },
        ],
        ['Coverage file', inputs.lcovFile],
        ['Coverage file exist', (!!rawCoverageReport).toString()],
        ['Coverage file entries', '0'],
        ['Total Covered', '0'],
        ['Total Uncovered', '0'],
      ])
      .write();
    console.log(`No coverage report found at '${inputs.lcovFile}', exiting...`);
    return;
  }
  if (inputs.debugLcov) {
    console.log('====================LCOV FILE REPORT====================');
    console.log(rawCoverageReport.toString());
    console.log('========================================================');
  }

  const result = parseLcov(rawCoverageReport.toString());
  const summary = generateSummary(result.covered, result.not_covered, {
    title: inputs.title,
    primary_color: inputs.primary_color,
    secondary_color: inputs.secondary_color,
  });
  const context = github.context;
  if (
    context.payload.pull_request &&
    ['opened', 'synchronize', 'reopened'].includes(github.context.payload.action || '') &&
    inputs.commentPr
  ) {
    const pull_request_number = context.payload.pull_request.number;
    const octokit = new github.getOctokit(inputs.githubToken);

    // Look for existing comment from this action
    const comments = await octokit.rest.issues.listComments({
      owner: context.repo.owner,
      repo: context.repo.repo,
      issue_number: pull_request_number,
    });

    const botComment = comments.data.find(comment => 
      comment.user?.login === 'LCovMan' || 
      comment.body?.includes('Generated by LCovMan ðŸ¦•')
    );

    if (botComment && github.context.payload.action !== 'opened') {
      // Update existing comment for synchronize/reopened
      await octokit.rest.issues.updateComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        comment_id: botComment.id,
        body: summary,
      });
    } else {
      // Create new comment for opened or if no existing comment found
      await octokit.rest.issues.createComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: pull_request_number,
        body: summary,
      });
    }
  }
  await core.summary
    .addTable([
      [
        { data: 'Details', header: true },
        { data: 'Result', header: true },
      ],
      ['Coverage file', inputs.lcovFile],
      ['Coverage file exist', (!!rawCoverageReport).toString()],
      [
        'Coverage file entries',
        (result.covered + result.not_covered).toString(),
      ],
      ['Total Covered', result.covered.toString()],
      ['Total Uncovered', result.not_covered.toString()],
      ['Coverage Percentage', `${result.percentage}%`],
    ])
    .addRaw('', true)
    .addRaw(summary)
    .write();
}
/**
 * Retrieves the inputs required for the operation.
 */
function isValidHexColor(color: string): boolean {
  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);
}

export function getInputs(): {
  githubToken: string;
  workingDir: string;
  lcovFile: string;
  commentPr: boolean;
  title: string;
  primary_color: string;
  secondary_color: string;
  debugLcov: boolean;
} {
  const lcovFile = getInputFilePath(
    core.getInput('lcov-file'),
    './coverage/lcov.info',
  );
  
  const primaryColor = getInputValue('pie-covered-color') || '#4CAF50';
  const secondaryColor = getInputValue('pie-not-covered-color') || '#FF5733';
  
  if (primaryColor && !isValidHexColor(primaryColor)) {
    core.warning(`Invalid primary color '${primaryColor}', using default #4CAF50`);
  }
  if (secondaryColor && !isValidHexColor(secondaryColor)) {
    core.warning(`Invalid secondary color '${secondaryColor}', using default #FF5733`);
  }
  
  return {
    githubToken: getInputValue('github-token'),
    workingDir: WORKING_DIR,
    lcovFile: lcovFile,
    commentPr: getInputBoolValue('comment-on-pr'),
    title: getInputValue('title'),
    primary_color: isValidHexColor(primaryColor) ? primaryColor : '#4CAF50',
    secondary_color: isValidHexColor(secondaryColor) ? secondaryColor : '#FF5733',
    debugLcov: getInputBoolValue('debug-lcov'),
  };
}
/**
 * Returns the input file path based on the input name and default value.
 */
export function getInputFilePath(
  inputName: string,
  defaultValue: string,
): string {
  return path.join(WORKING_DIR, core.getInput(inputName) || defaultValue);
}

/**
 * Retrieves the value of the specified input.
 */
export function getInputValue(inputName: string): string {
  return core.getInput(inputName);
}

/**
 * Returns the boolean value of the specified input.
 */
export function getInputBoolValue(inputName: string): boolean {
  return core.getBooleanInput(inputName);
}

/**
 * Reads a file from the specified file path safely.
 */
export function readFileSafe(filepath: string): string | undefined {
  try {
    return fs.readFileSync(filepath, 'utf8');
  } catch {
    return undefined;
  }
}

if (require.main === module) {
  // Code to be executed only when the script is run directly
  main().catch(function (err) {
    console.log(err);
    core.setFailed(err.message);
  });
}
