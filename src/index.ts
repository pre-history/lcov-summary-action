import * as core from '@actions/core';
import * as github from '@actions/github';
import * as fs from 'fs';
import * as path from 'path';
import { parseLcov, compareLcov } from './lcov_parser';
import { generateSummary, generateDetailedSummary } from './summary';
/**
 * Represents the working directory.
 *
 * @type {string}
 */
const WORKING_DIR = core.getInput('working-directory');
/**
 * Entry point of the program.
 *
 * @async
 * @function main
 * @returns {void}
 */
async function main() {
  const inputs = getInputs();
  const rawCoverageReport = readFileSafe(inputs.lcovFile);
  if (!rawCoverageReport) {
    await core.summary
      .addTable([
        [
          { data: 'Details', header: true },
          { data: 'Result', header: true },
        ],
        ['Coverage file', inputs.lcovFile],
        ['Coverage file exist', (!!rawCoverageReport).toString()],
        ['Coverage file entries', '0'],
        ['Total Covered', '0'],
        ['Total Uncovered', '0'],
      ])
      .write();
    console.log(`No coverage report found at '${inputs.lcovFile}', exiting...`);
    return;
  }
  if (inputs.debugLcov) {
    console.log('====================LCOV FILE REPORT====================');
    console.log(rawCoverageReport.toString());
    console.log('========================================================');
  }

  const result = parseLcov(rawCoverageReport.toString());

  // Parse base LCOV file if provided
  let baseResult = undefined;
  let diff = null;
  if (inputs.baseLcovFile) {
    const rawBaseReport = readFileSafe(inputs.baseLcovFile);
    if (rawBaseReport) {
      baseResult = parseLcov(rawBaseReport.toString());
      diff = compareLcov(result, baseResult);
    } else {
      core.warning(`Base LCOV file not found at '${inputs.baseLcovFile}'`);
    }
  }

  // Generate summary based on detailed mode
  const summary = inputs.detailedSummary
    ? generateDetailedSummary(result, diff, {
        title: inputs.title,
        primary_color: inputs.primary_color,
        secondary_color: inputs.secondary_color,
        max_files_shown: inputs.maxFilesShown,
        coverage_threshold: inputs.coverageThreshold,
        generate_badge: inputs.generateBadge,
        badge_style: inputs.badgeStyle,
        show_coverage_sprite: inputs.showCoverageSprite,
      })
    : generateSummary(result.covered, result.not_covered, {
        title: inputs.title,
        primary_color: inputs.primary_color,
        secondary_color: inputs.secondary_color,
        show_coverage_sprite: inputs.showCoverageSprite,
      });
  const context = github.context;

  // Debug logging for PR comment functionality
  console.log('üîç Debug: PR Comment Analysis');
  console.log('- Event name:', context.eventName);
  console.log('- Action:', context.payload.action);
  console.log('- Has PR payload:', !!context.payload.pull_request);
  console.log('- Comment PR enabled:', inputs.commentPr);
  console.log(
    '- Valid actions:',
    ['opened', 'synchronize', 'reopened'].includes(
      context.payload.action || '',
    ),
  );

  if (
    context.payload.pull_request &&
    ['opened', 'synchronize', 'reopened'].includes(
      github.context.payload.action || '',
    ) &&
    inputs.commentPr
  ) {
    console.log('üìù Entering PR comment logic...');
    const pull_request_number = context.payload.pull_request.number;
    console.log('- PR Number:', pull_request_number);

    const octokit = new github.getOctokit(inputs.githubToken);

    try {
      // Look for existing comment from this action
      console.log('üîç Looking for existing comments...');
      const comments = await octokit.rest.issues.listComments({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: pull_request_number,
      });

      console.log('- Found', comments.data.length, 'comments total');

      const botComment = comments.data.find(
        (comment) =>
          comment.user?.login === 'LCovMan' ||
          comment.body?.includes('Generated by LCovMan ü¶ï'),
      );

      console.log('- Found existing LCovMan comment:', !!botComment);
      if (botComment) {
        console.log('- Existing comment ID:', botComment.id);
        console.log('- Comment author:', botComment.user?.login);
      }

      if (botComment && github.context.payload.action !== 'opened') {
        // Update existing comment for synchronize/reopened
        console.log('üîÑ Updating existing comment...');
        await octokit.rest.issues.updateComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          comment_id: botComment.id,
          body: summary,
        });
        console.log('‚úÖ Comment updated successfully');
      } else {
        // Create new comment for opened or if no existing comment found
        console.log('üìÑ Creating new comment...');
        await octokit.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: pull_request_number,
          body: summary,
        });
        console.log('‚úÖ Comment created successfully');
      }
    } catch (error) {
      console.error('‚ùå Error in comment logic:', error);
    }
  } else {
    console.log('‚è≠Ô∏è Skipping PR comment (conditions not met)');
  }

  // Check coverage thresholds and fail if needed
  let shouldFail = false;
  const failureReasons: string[] = [];

  // Check minimum coverage threshold
  if (result.percentage < inputs.coverageThreshold) {
    shouldFail = true;
    failureReasons.push(
      `Coverage ${result.percentage}% is below threshold ${inputs.coverageThreshold}%`,
    );
  }

  // Check for coverage decrease if base comparison is available
  if (inputs.failOnDecrease && diff && diff.percentage_diff < 0) {
    shouldFail = true;
    failureReasons.push(
      `Coverage decreased by ${Math.abs(diff.percentage_diff)}%`,
    );
  }

  if (shouldFail) {
    const errorMessage = `‚ùå Coverage check failed: ${failureReasons.join(', ')}`;
    core.setFailed(errorMessage);
    console.error(errorMessage);
  } else {
    const threshold = inputs.coverageThreshold;
    const status = result.percentage >= threshold ? '‚úÖ' : '‚ö†Ô∏è';
    console.log(
      `${status} Coverage: ${result.percentage}% (threshold: ${threshold}%)`,
    );
  }

  // Generate badge if requested
  if (inputs.generateBadge) {
    const badge = generateCoverageBadge(result.percentage, inputs.badgeStyle);
    core.info(`Coverage Badge URL: ${badge.url}`);
    core.info(`Coverage Badge Markdown: ${badge.markdown}`);

    // Add to summary
    core.summary
      .addHeading('Coverage Badge', 3)
      .addRaw(
        `Copy this to your README.md:\n\n\`\`\`markdown\n${badge.markdown}\n\`\`\`\n\n`,
      )
      .addRaw(`Preview: ${badge.markdown}\n\n`);
  }

  await core.summary
    .addTable([
      [
        { data: 'Details', header: true },
        { data: 'Result', header: true },
      ],
      ['Coverage file', inputs.lcovFile],
      ['Coverage file exist', (!!rawCoverageReport).toString()],
      [
        'Coverage file entries',
        (result.covered + result.not_covered).toString(),
      ],
      ['Total Covered', result.covered.toString()],
      ['Total Uncovered', result.not_covered.toString()],
      ['Coverage Percentage', `${result.percentage}%`],
      ['Coverage Threshold', `${inputs.coverageThreshold}%`],
      [
        'Threshold Status',
        result.percentage >= inputs.coverageThreshold ? '‚úÖ Pass' : '‚ùå Fail',
      ],
      ['Files Analyzed', result.total_files.toString()],
    ])
    .addRaw('', true)
    .addRaw(summary)
    .write();
}
/**
 * Retrieves the inputs required for the operation.
 */
function isValidHexColor(color: string): boolean {
  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);
}

/**
 * Validates if the badge style is supported by shields.io
 */
function isValidBadgeStyle(style: string): boolean {
  const validStyles = [
    'flat',
    'flat-square',
    'plastic',
    'for-the-badge',
    'social',
  ];
  return validStyles.includes(style);
}

/**
 * Generates a coverage badge URL and markdown.
 */
function generateCoverageBadge(
  percentage: number,
  style: string = 'flat',
): { url: string; markdown: string } {
  // Determine color based on coverage percentage
  let color = 'red';
  if (percentage >= 80) color = 'brightgreen';
  else if (percentage >= 60) color = 'yellow';
  else if (percentage >= 40) color = 'orange';

  const percentageText = `${percentage}%25`; // URL encode the % symbol
  const url = `https://img.shields.io/badge/coverage-${percentageText}-${color}?style=${style}`;
  const markdown = `![Coverage](${url})`;

  return { url, markdown };
}

export function getInputs(): {
  githubToken: string;
  workingDir: string;
  lcovFile: string;
  baseLcovFile?: string;
  commentPr: boolean;
  title: string;
  primary_color: string;
  secondary_color: string;
  debugLcov: boolean;
  detailedSummary: boolean;
  maxFilesShown: number;
  coverageThreshold: number;
  failOnDecrease: boolean;
  generateBadge: boolean;
  badgeStyle: string;
  showCoverageSprite: boolean;
} {
  const lcovFile = getInputFilePath(
    core.getInput('lcov-file'),
    './coverage/lcov.info',
  );

  const baseLcovInput = getInputValue('base-lcov-file');
  const baseLcovFile = baseLcovInput
    ? getInputFilePath(baseLcovInput, '')
    : undefined;

  const primaryColor = getInputValue('pie-covered-color') || '#4CAF50';
  const secondaryColor = getInputValue('pie-not-covered-color') || '#FF5733';

  if (primaryColor && !isValidHexColor(primaryColor)) {
    core.warning(
      `Invalid primary color '${primaryColor}', using default #4CAF50`,
    );
  }
  if (secondaryColor && !isValidHexColor(secondaryColor)) {
    core.warning(
      `Invalid secondary color '${secondaryColor}', using default #FF5733`,
    );
  }

  const maxFilesInput = getInputValue('max-files-shown');
  const maxFilesShown = maxFilesInput ? parseInt(maxFilesInput, 10) : 10;
  if (isNaN(maxFilesShown) || maxFilesShown < 1) {
    core.warning(
      `Invalid max-files-shown '${maxFilesInput}', using default 10`,
    );
  }

  const thresholdInput = getInputValue('coverage-threshold');
  const coverageThreshold = thresholdInput ? parseFloat(thresholdInput) : 70;
  if (
    isNaN(coverageThreshold) ||
    coverageThreshold < 0 ||
    coverageThreshold > 100
  ) {
    core.warning(
      `Invalid coverage-threshold '${thresholdInput}', using default 70`,
    );
  }

  return {
    githubToken: getInputValue('github-token'),
    workingDir: WORKING_DIR,
    lcovFile: lcovFile,
    baseLcovFile: baseLcovFile,
    commentPr: getInputBoolValue('comment-on-pr'),
    title: getInputValue('title'),
    primary_color: isValidHexColor(primaryColor) ? primaryColor : '#4CAF50',
    secondary_color: isValidHexColor(secondaryColor)
      ? secondaryColor
      : '#FF5733',
    debugLcov: getInputBoolValue('debug-lcov'),
    detailedSummary: getInputBoolValue('detailed-summary'),
    maxFilesShown:
      !isNaN(maxFilesShown) && maxFilesShown >= 1 ? maxFilesShown : 10,
    coverageThreshold:
      !isNaN(coverageThreshold) &&
      coverageThreshold >= 0 &&
      coverageThreshold <= 100
        ? coverageThreshold
        : 70,
    failOnDecrease: getInputBoolValue('fail-on-coverage-decrease'),
    generateBadge: getInputBoolValue('generate-badge'),
    badgeStyle: (() => {
      const style = getInputValue('badge-style') || 'flat';
      if (!isValidBadgeStyle(style)) {
        core.warning(
          `Invalid badge-style '${style}', using default 'flat'. Valid styles: flat, flat-square, plastic, for-the-badge, social`,
        );
        return 'flat';
      }
      return style;
    })(),
    showCoverageSprite: getInputBoolValue('show-coverage-sprite'),
  };
}
/**
 * Returns the input file path based on the input name and default value.
 */
export function getInputFilePath(
  inputName: string,
  defaultValue: string,
): string {
  return path.join(WORKING_DIR, core.getInput(inputName) || defaultValue);
}

/**
 * Retrieves the value of the specified input.
 */
export function getInputValue(inputName: string): string {
  return core.getInput(inputName);
}

/**
 * Returns the boolean value of the specified input.
 */
export function getInputBoolValue(inputName: string): boolean {
  return core.getBooleanInput(inputName);
}

/**
 * Reads a file from the specified file path safely.
 */
export function readFileSafe(filepath: string): string | undefined {
  try {
    return fs.readFileSync(filepath, 'utf8');
  } catch {
    return undefined;
  }
}

if (require.main === module) {
  // Code to be executed only when the script is run directly
  main().catch(function (err) {
    console.log(err);
    core.setFailed(err.message);
  });
}
